import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';
import ora from 'ora';
import Handlebars from 'handlebars';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export interface ProjectOptions {
  template: 'basic' | 'advanced' | 'enterprise';
  deafauth: boolean;
  pinksync: boolean;
  fibonrose: boolean;
  deafUi: boolean;
  ai: boolean;
  output: string;
}

export async function createProject(
  projectName: string,
  options: ProjectOptions
): Promise<void> {
  const spinner = ora('Creating project structure...').start();
  
  const outputDir = path.resolve(options.output, projectName);
  
  try {
    // Create project directory
    await fs.ensureDir(outputDir);
    
    // Generate package.json
    spinner.text = 'Generating package.json...';
    await generatePackageJson(outputDir, projectName, options);
    
    // Generate tsconfig.json
    spinner.text = 'Generating TypeScript config...';
    await generateTsConfig(outputDir);
    
    // Generate frontend
    spinner.text = 'Generating frontend...';
    await generateFrontend(outputDir, projectName, options);
    
    // Generate backend
    spinner.text = 'Generating backend...';
    await generateBackend(outputDir, projectName, options);
    
    // Generate environment files
    spinner.text = 'Generating environment configuration...';
    await generateEnvFiles(outputDir, options);
    
    // Generate README
    spinner.text = 'Generating documentation...';
    await generateReadme(outputDir, projectName, options);
    
    spinner.succeed(chalk.green('Project created successfully!'));
    
    console.log(chalk.blue('\nüìÅ Project Structure:'));
    console.log(chalk.gray(`
${projectName}/
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.tsx
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ vite.config.ts
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ README.md
`));
    
    console.log(chalk.yellow('\nüöÄ Next Steps:'));
    console.log(chalk.white(`  1. cd ${projectName}`));
    console.log(chalk.white('  2. npm install'));
    console.log(chalk.white('  3. cp .env.example .env'));
    console.log(chalk.white('  4. npm run dev\n'));
    
    if (options.deafauth) {
      console.log(chalk.cyan('üì¶ DeafAUTH Integration: Enabled'));
    }
    if (options.pinksync) {
      console.log(chalk.magenta('üì¶ PinkSync Integration: Enabled'));
    }
    if (options.fibonrose) {
      console.log(chalk.yellow('üì¶ FibonRose Integration: Enabled'));
    }
    if (options.deafUi) {
      console.log(chalk.green('üì¶ Deaf UI Components: Enabled'));
    }
    if (options.ai) {
      console.log(chalk.blue('üì¶ AI Services: Enabled'));
    }
    
  } catch (error) {
    spinner.fail(chalk.red('Failed to create project'));
    console.error(error);
    throw error;
  }
}

async function generatePackageJson(
  outputDir: string,
  projectName: string,
  options: ProjectOptions
): Promise<void> {
  const dependencies: Record<string, string> = {};
  const workspaces = ['frontend', 'backend'];
  
  if (options.deafauth) {
    dependencies['@deaf-first/deafauth'] = 'workspace:*';
  }
  if (options.pinksync) {
    dependencies['@deaf-first/pinksync'] = 'workspace:*';
  }
  if (options.fibonrose) {
    dependencies['@deaf-first/fibonrose'] = 'workspace:*';
  }
  if (options.deafUi) {
    dependencies['@deaf-first/deaf-ui'] = 'workspace:*';
  }
  
  const packageJson = {
    name: projectName,
    version: '1.0.0',
    private: true,
    description: `${projectName} - Generated by DEAF-FIRST Platform`,
    type: 'module',
    workspaces,
    scripts: {
      dev: 'concurrently -n "FRONT,BACK" -c "cyan,magenta" "npm run dev:frontend" "npm run dev:backend"',
      'dev:frontend': 'npm run dev --workspace=frontend',
      'dev:backend': 'npm run dev --workspace=backend',
      build: 'npm run build --workspaces --if-present',
      test: 'npm run test --workspaces --if-present',
      lint: 'npm run lint --workspaces --if-present',
    },
    dependencies,
    devDependencies: {
      concurrently: '^9.1.0',
      typescript: '^5.7.2',
    },
    engines: {
      node: '>=20.0.0',
    },
  };
  
  await fs.writeJson(path.join(outputDir, 'package.json'), packageJson, { spaces: 2 });
}

async function generateTsConfig(outputDir: string): Promise<void> {
  const tsConfig = {
    compilerOptions: {
      target: 'ES2022',
      module: 'ESNext',
      moduleResolution: 'bundler',
      esModuleInterop: true,
      strict: true,
      skipLibCheck: true,
    },
    references: [
      { path: './frontend' },
      { path: './backend' },
    ],
  };
  
  await fs.writeJson(path.join(outputDir, 'tsconfig.json'), tsConfig, { spaces: 2 });
}

async function generateFrontend(
  outputDir: string,
  projectName: string,
  options: ProjectOptions
): Promise<void> {
  const frontendDir = path.join(outputDir, 'frontend');
  
  // Create directories
  await fs.ensureDir(path.join(frontendDir, 'src', 'components'));
  await fs.ensureDir(path.join(frontendDir, 'src', 'hooks'));
  await fs.ensureDir(path.join(frontendDir, 'src', 'services'));
  await fs.ensureDir(path.join(frontendDir, 'src', 'pages'));
  await fs.ensureDir(path.join(frontendDir, 'public'));
  
  // Generate package.json
  const frontendPackageJson = {
    name: `${projectName}-frontend`,
    version: '1.0.0',
    private: true,
    type: 'module',
    scripts: {
      dev: 'vite',
      build: 'tsc && vite build',
      preview: 'vite preview',
      test: 'vitest',
      lint: 'eslint . --ext ts,tsx',
    },
    dependencies: {
      react: '^18.3.1',
      'react-dom': '^18.3.1',
      '@tanstack/react-query': '^5.59.20',
      axios: '^1.7.8',
      'react-router-dom': '^6.28.0',
      ...(options.deafUi ? { '@deaf-first/deaf-ui': 'workspace:*' } : {}),
    },
    devDependencies: {
      '@types/react': '^18.3.12',
      '@types/react-dom': '^18.3.1',
      '@vitejs/plugin-react': '^4.3.4',
      typescript: '^5.7.2',
      vite: '^6.0.1',
      vitest: '^2.1.5',
    },
  };
  
  await fs.writeJson(path.join(frontendDir, 'package.json'), frontendPackageJson, { spaces: 2 });
  
  // Generate vite.config.ts
  const viteConfig = `import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
      },
    },
  },
});
`;
  await fs.writeFile(path.join(frontendDir, 'vite.config.ts'), viteConfig);
  
  // Generate tsconfig.json
  const frontendTsConfig = {
    compilerOptions: {
      target: 'ES2020',
      useDefineForClassFields: true,
      lib: ['ES2020', 'DOM', 'DOM.Iterable'],
      module: 'ESNext',
      skipLibCheck: true,
      moduleResolution: 'bundler',
      allowImportingTsExtensions: true,
      resolveJsonModule: true,
      isolatedModules: true,
      noEmit: true,
      jsx: 'react-jsx',
      strict: true,
      noUnusedLocals: true,
      noUnusedParameters: true,
      noFallthroughCasesInSwitch: true,
    },
    include: ['src'],
  };
  await fs.writeJson(path.join(frontendDir, 'tsconfig.json'), frontendTsConfig, { spaces: 2 });
  
  // Generate index.html
  const indexHtml = `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/deaf-first.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="${projectName} - Powered by DEAF-FIRST Platform" />
    <title>${projectName}</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
`;
  await fs.writeFile(path.join(frontendDir, 'index.html'), indexHtml);
  
  // Generate main.tsx
  const mainTsx = `import React from 'react';
import ReactDOM from 'react-dom/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './index.css';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,
      retry: 1,
    },
  },
});

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </QueryClientProvider>
  </React.StrictMode>
);
`;
  await fs.writeFile(path.join(frontendDir, 'src', 'main.tsx'), mainTsx);
  
  // Generate App.tsx
  const appTsx = generateAppComponent(projectName, options);
  await fs.writeFile(path.join(frontendDir, 'src', 'App.tsx'), appTsx);
  
  // Generate index.css
  const indexCss = generateIndexCss();
  await fs.writeFile(path.join(frontendDir, 'src', 'index.css'), indexCss);
  
  // Generate services
  await generateFrontendServices(frontendDir, options);
  
  // Generate hooks
  await generateFrontendHooks(frontendDir, options);
}

function generateAppComponent(projectName: string, options: ProjectOptions): string {
  const imports: string[] = [
    "import { Routes, Route } from 'react-router-dom';",
    "import './index.css';",
  ];
  
  if (options.deafauth) {
    imports.push("import { useAuth } from './hooks/useAuth';");
  }
  
  return `${imports.join('\n')}

function App() {
  ${options.deafauth ? 'const { user, isLoading } = useAuth();' : ''}

  return (
    <div className="app">
      <header className="app-header">
        <nav className="nav-container" role="navigation" aria-label="Main navigation">
          <div className="logo">
            <h1>${projectName}</h1>
          </div>
          <ul className="nav-links">
            <li><a href="/" className="nav-link">Home</a></li>
            <li><a href="/dashboard" className="nav-link">Dashboard</a></li>
            ${options.deafauth ? '<li><a href="/login" className="nav-link">Login</a></li>' : ''}
          </ul>
        </nav>
      </header>

      <main className="app-main" role="main">
        <section className="hero-section" aria-labelledby="hero-title">
          <h2 id="hero-title">Welcome to ${projectName}</h2>
          <p>A production-ready SaaS application powered by DEAF-FIRST Platform</p>
          
          <div className="features-grid" role="list">
            ${options.deafauth ? `
            <div className="feature-card" role="listitem">
              <span className="feature-icon" aria-hidden="true">üîê</span>
              <h3>DeafAUTH</h3>
              <p>Accessible authentication with sign language support</p>
            </div>` : ''}
            ${options.pinksync ? `
            <div className="feature-card" role="listitem">
              <span className="feature-icon" aria-hidden="true">üîÑ</span>
              <h3>PinkSync</h3>
              <p>Real-time data synchronization</p>
            </div>` : ''}
            ${options.fibonrose ? `
            <div className="feature-card" role="listitem">
              <span className="feature-icon" aria-hidden="true">üìä</span>
              <h3>FibonRose</h3>
              <p>Mathematical optimization algorithms</p>
            </div>` : ''}
            ${options.deafUi ? `
            <div className="feature-card" role="listitem">
              <span className="feature-icon" aria-hidden="true">‚ôø</span>
              <h3>Deaf UI</h3>
              <p>Accessible component library</p>
            </div>` : ''}
            ${options.ai ? `
            <div className="feature-card" role="listitem">
              <span className="feature-icon" aria-hidden="true">ü§ñ</span>
              <h3>AI Services</h3>
              <p>AI-powered workflows and automation</p>
            </div>` : ''}
          </div>
        </section>
      </main>

      <footer className="app-footer" role="contentinfo">
        <p>&copy; ${new Date().getFullYear()} ${projectName} - Powered by DEAF-FIRST Platform</p>
      </footer>
    </div>
  );
}

export default App;
`;
}

function generateIndexCss(): string {
  return `:root {
  --primary-color: #4f46e5;
  --primary-hover: #4338ca;
  --secondary-color: #10b981;
  --background-color: #f8fafc;
  --surface-color: #ffffff;
  --text-primary: #1e293b;
  --text-secondary: #64748b;
  --border-color: #e2e8f0;
  --focus-ring: 0 0 0 3px rgba(79, 70, 229, 0.4);
  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
  --radius-sm: 0.375rem;
  --radius-md: 0.5rem;
  --radius-lg: 0.75rem;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
  background-color: var(--background-color);
  color: var(--text-primary);
  line-height: 1.6;
  min-height: 100vh;
}

/* Focus styles for accessibility */
*:focus-visible {
  outline: none;
  box-shadow: var(--focus-ring);
}

.app {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

/* Header Styles */
.app-header {
  background-color: var(--surface-color);
  border-bottom: 1px solid var(--border-color);
  padding: 1rem 2rem;
  position: sticky;
  top: 0;
  z-index: 100;
}

.nav-container {
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.logo h1 {
  font-size: 1.5rem;
  color: var(--primary-color);
  font-weight: 700;
}

.nav-links {
  display: flex;
  gap: 2rem;
  list-style: none;
}

.nav-link {
  color: var(--text-secondary);
  text-decoration: none;
  font-weight: 500;
  padding: 0.5rem 1rem;
  border-radius: var(--radius-sm);
  transition: all 0.2s ease;
}

.nav-link:hover,
.nav-link:focus {
  color: var(--primary-color);
  background-color: rgba(79, 70, 229, 0.1);
}

/* Main Content */
.app-main {
  flex: 1;
  max-width: 1200px;
  margin: 0 auto;
  padding: 3rem 2rem;
  width: 100%;
}

.hero-section {
  text-align: center;
  margin-bottom: 4rem;
}

.hero-section h2 {
  font-size: 2.5rem;
  margin-bottom: 1rem;
  color: var(--text-primary);
}

.hero-section p {
  font-size: 1.25rem;
  color: var(--text-secondary);
  max-width: 600px;
  margin: 0 auto 3rem;
}

/* Feature Grid */
.features-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 1.5rem;
  margin-top: 2rem;
}

.feature-card {
  background-color: var(--surface-color);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-lg);
  padding: 2rem;
  text-align: center;
  transition: all 0.3s ease;
  box-shadow: var(--shadow-sm);
}

.feature-card:hover {
  transform: translateY(-4px);
  box-shadow: var(--shadow-lg);
  border-color: var(--primary-color);
}

.feature-icon {
  font-size: 3rem;
  display: block;
  margin-bottom: 1rem;
}

.feature-card h3 {
  font-size: 1.25rem;
  margin-bottom: 0.5rem;
  color: var(--text-primary);
}

.feature-card p {
  color: var(--text-secondary);
  font-size: 0.95rem;
}

/* Footer */
.app-footer {
  background-color: var(--surface-color);
  border-top: 1px solid var(--border-color);
  padding: 2rem;
  text-align: center;
  color: var(--text-secondary);
}

/* Buttons */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0.75rem 1.5rem;
  font-size: 1rem;
  font-weight: 500;
  border-radius: var(--radius-md);
  border: none;
  cursor: pointer;
  transition: all 0.2s ease;
}

.btn-primary {
  background-color: var(--primary-color);
  color: white;
}

.btn-primary:hover,
.btn-primary:focus {
  background-color: var(--primary-hover);
}

.btn-secondary {
  background-color: transparent;
  color: var(--primary-color);
  border: 2px solid var(--primary-color);
}

.btn-secondary:hover,
.btn-secondary:focus {
  background-color: rgba(79, 70, 229, 0.1);
}

/* Accessibility */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  border: 0;
}

/* Skip Link */
.skip-link {
  position: absolute;
  top: -100%;
  left: 50%;
  transform: translateX(-50%);
  background-color: var(--primary-color);
  color: white;
  padding: 1rem 2rem;
  text-decoration: none;
  border-radius: var(--radius-md);
  z-index: 1000;
}

.skip-link:focus {
  top: 1rem;
}

/* Responsive Design */
@media (max-width: 768px) {
  .nav-container {
    flex-direction: column;
    gap: 1rem;
  }

  .nav-links {
    gap: 1rem;
  }

  .hero-section h2 {
    font-size: 2rem;
  }

  .features-grid {
    grid-template-columns: 1fr;
  }
}

/* High Contrast Mode */
@media (prefers-contrast: high) {
  :root {
    --primary-color: #0000ff;
    --text-primary: #000000;
    --text-secondary: #333333;
    --border-color: #000000;
  }
}

/* Reduced Motion */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}
`;
}

async function generateFrontendServices(
  frontendDir: string,
  options: ProjectOptions
): Promise<void> {
  // API service
  const apiService = `import axios from 'axios';

const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL || '/api',
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor for auth token
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('auth_token');
  if (token) {
    config.headers.Authorization = \`Bearer \${token}\`;
  }
  return config;
});

// Response interceptor for error handling
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem('auth_token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default api;
`;
  await fs.writeFile(path.join(frontendDir, 'src', 'services', 'api.ts'), apiService);
  
  if (options.deafauth) {
    const authService = `import api from './api';

export interface User {
  id: string;
  username: string;
  email: string;
  accessibilityPreferences?: {
    signLanguage: boolean;
    highContrast: boolean;
    largeText: boolean;
  };
}

export interface LoginCredentials {
  username: string;
  password: string;
}

export interface RegisterData extends LoginCredentials {
  email: string;
  accessibilityPreferences?: User['accessibilityPreferences'];
}

export const authService = {
  async login(credentials: LoginCredentials): Promise<{ token: string; user: User }> {
    const response = await api.post('/auth/login', credentials);
    return response.data;
  },

  async register(data: RegisterData): Promise<{ user: User }> {
    const response = await api.post('/auth/register', data);
    return response.data;
  },

  async getCurrentUser(): Promise<User> {
    const response = await api.get('/auth/me');
    return response.data.user;
  },

  async updatePreferences(preferences: User['accessibilityPreferences']): Promise<User> {
    const response = await api.put('/auth/preferences', { accessibilityPreferences: preferences });
    return response.data.user;
  },

  logout(): void {
    localStorage.removeItem('auth_token');
  },
};
`;
    await fs.writeFile(path.join(frontendDir, 'src', 'services', 'auth.ts'), authService);
  }
  
  if (options.pinksync) {
    const syncService = `import api from './api';

export interface SyncData {
  channel: string;
  data: Record<string, unknown>;
}

export interface SyncStatus {
  status: string;
  activeChannels: number;
  connectedClients: number;
}

export const syncService = {
  async sync(data: SyncData): Promise<{ syncId: string }> {
    const response = await api.post('/sync', data);
    return response.data;
  },

  async getStatus(): Promise<SyncStatus> {
    const response = await api.get('/sync/status');
    return response.data;
  },

  createWebSocket(channel: string): WebSocket {
    const wsUrl = import.meta.env.VITE_WS_URL || 'ws://localhost:3003';
    return new WebSocket(\`\${wsUrl}/ws/\${channel}\`);
  },
};
`;
    await fs.writeFile(path.join(frontendDir, 'src', 'services', 'sync.ts'), syncService);
  }
  
  if (options.fibonrose) {
    const optimizeService = `import api from './api';

export interface Task {
  id: string;
  name: string;
  priority: number;
  duration?: number;
}

export interface OptimizedSchedule {
  tasks: Task[];
  efficiency: number;
}

export const optimizeService = {
  async optimizeSchedule(tasks: Task[]): Promise<OptimizedSchedule> {
    const response = await api.post('/optimize/schedule', { tasks });
    return response.data;
  },

  async getFibonacci(n: number): Promise<{ position: number; value: number }> {
    const response = await api.get(\`/fibonacci/\${n}\`);
    return response.data;
  },

  async goldenRatio(value: number): Promise<{
    inputValue: number;
    goldenRatio: number;
    multiplied: number;
    divided: number;
  }> {
    const response = await api.post('/golden-ratio', { value });
    return response.data;
  },
};
`;
    await fs.writeFile(path.join(frontendDir, 'src', 'services', 'optimize.ts'), optimizeService);
  }
}

async function generateFrontendHooks(
  frontendDir: string,
  options: ProjectOptions
): Promise<void> {
  if (options.deafauth) {
    const useAuthHook = `import { useState, useEffect, useCallback } from 'react';
import { authService, type User } from '../services/auth';

interface AuthState {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  error: string | null;
}

export function useAuth() {
  const [state, setState] = useState<AuthState>({
    user: null,
    isLoading: true,
    isAuthenticated: false,
    error: null,
  });

  const checkAuth = useCallback(async () => {
    const token = localStorage.getItem('auth_token');
    if (!token) {
      setState({ user: null, isLoading: false, isAuthenticated: false, error: null });
      return;
    }

    try {
      const user = await authService.getCurrentUser();
      setState({ user, isLoading: false, isAuthenticated: true, error: null });
    } catch {
      localStorage.removeItem('auth_token');
      setState({ user: null, isLoading: false, isAuthenticated: false, error: null });
    }
  }, []);

  useEffect(() => {
    checkAuth();
  }, [checkAuth]);

  const login = async (username: string, password: string) => {
    setState((prev) => ({ ...prev, isLoading: true, error: null }));
    try {
      const { token, user } = await authService.login({ username, password });
      localStorage.setItem('auth_token', token);
      setState({ user, isLoading: false, isAuthenticated: true, error: null });
      return true;
    } catch (err) {
      setState((prev) => ({
        ...prev,
        isLoading: false,
        error: err instanceof Error ? err.message : 'Login failed',
      }));
      return false;
    }
  };

  const logout = () => {
    authService.logout();
    setState({ user: null, isLoading: false, isAuthenticated: false, error: null });
  };

  return { ...state, login, logout, checkAuth };
}
`;
    await fs.writeFile(path.join(frontendDir, 'src', 'hooks', 'useAuth.ts'), useAuthHook);
  }
  
  if (options.pinksync) {
    const useSyncHook = `import { useState, useEffect, useCallback, useRef } from 'react';
import { syncService } from '../services/sync';

interface SyncState {
  isConnected: boolean;
  lastMessage: unknown | null;
  error: string | null;
}

export function useSync(channel: string) {
  const [state, setState] = useState<SyncState>({
    isConnected: false,
    lastMessage: null,
    error: null,
  });
  
  const wsRef = useRef<WebSocket | null>(null);

  const connect = useCallback(() => {
    if (wsRef.current?.readyState === WebSocket.OPEN) return;

    const ws = syncService.createWebSocket(channel);
    wsRef.current = ws;

    ws.onopen = () => {
      setState((prev) => ({ ...prev, isConnected: true, error: null }));
    };

    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        setState((prev) => ({ ...prev, lastMessage: data }));
      } catch {
        setState((prev) => ({ ...prev, lastMessage: event.data }));
      }
    };

    ws.onerror = () => {
      setState((prev) => ({ ...prev, error: 'WebSocket error' }));
    };

    ws.onclose = () => {
      setState((prev) => ({ ...prev, isConnected: false }));
    };
  }, [channel]);

  const disconnect = useCallback(() => {
    wsRef.current?.close();
  }, []);

  const send = useCallback((data: unknown) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(data));
    }
  }, []);

  useEffect(() => {
    connect();
    return () => disconnect();
  }, [connect, disconnect]);

  return { ...state, connect, disconnect, send };
}
`;
    await fs.writeFile(path.join(frontendDir, 'src', 'hooks', 'useSync.ts'), useSyncHook);
  }
}

async function generateBackend(
  outputDir: string,
  projectName: string,
  options: ProjectOptions
): Promise<void> {
  const backendDir = path.join(outputDir, 'backend');
  
  // Create directories
  await fs.ensureDir(path.join(backendDir, 'src', 'routes'));
  await fs.ensureDir(path.join(backendDir, 'src', 'middleware'));
  await fs.ensureDir(path.join(backendDir, 'src', 'services'));
  
  // Generate package.json
  const backendPackageJson = {
    name: `${projectName}-backend`,
    version: '1.0.0',
    private: true,
    type: 'module',
    scripts: {
      dev: 'tsx watch src/index.ts',
      build: 'tsc',
      start: 'node dist/index.js',
      test: 'vitest',
      lint: 'eslint . --ext ts',
    },
    dependencies: {
      express: '^4.21.1',
      cors: '^2.8.5',
      helmet: '^8.0.0',
      dotenv: '^16.4.5',
      jsonwebtoken: '^9.0.2',
      bcrypt: '^5.1.1',
      ...(options.pinksync ? { ws: '^8.18.0' } : {}),
    },
    devDependencies: {
      '@types/express': '^5.0.0',
      '@types/cors': '^2.8.17',
      '@types/node': '^22.10.2',
      '@types/jsonwebtoken': '^9.0.7',
      '@types/bcrypt': '^5.0.2',
      ...(options.pinksync ? { '@types/ws': '^8.5.13' } : {}),
      tsx: '^4.19.2',
      typescript: '^5.7.2',
      vitest: '^2.1.5',
    },
  };
  
  await fs.writeJson(path.join(backendDir, 'package.json'), backendPackageJson, { spaces: 2 });
  
  // Generate tsconfig.json
  const backendTsConfig = {
    compilerOptions: {
      target: 'ES2022',
      module: 'ESNext',
      moduleResolution: 'bundler',
      esModuleInterop: true,
      strict: true,
      skipLibCheck: true,
      declaration: true,
      outDir: 'dist',
      rootDir: 'src',
    },
    include: ['src/**/*'],
    exclude: ['node_modules', 'dist'],
  };
  await fs.writeJson(path.join(backendDir, 'tsconfig.json'), backendTsConfig, { spaces: 2 });
  
  // Generate index.ts
  const indexTs = generateBackendIndex(projectName, options);
  await fs.writeFile(path.join(backendDir, 'src', 'index.ts'), indexTs);
  
  // Generate routes
  await generateBackendRoutes(backendDir, options);
  
  // Generate middleware
  await generateBackendMiddleware(backendDir);
  
  // Generate services
  await generateBackendServices(backendDir, options);
}

function generateBackendIndex(projectName: string, options: ProjectOptions): string {
  const imports = [
    "import express from 'express';",
    "import cors from 'cors';",
    "import helmet from 'helmet';",
    "import dotenv from 'dotenv';",
    "import { authMiddleware } from './middleware/auth.js';",
    "import healthRouter from './routes/health.js';",
  ];
  
  if (options.deafauth) {
    imports.push("import authRouter from './routes/auth.js';");
  }
  if (options.pinksync) {
    imports.push("import syncRouter from './routes/sync.js';");
    imports.push("import { createWebSocketServer } from './services/websocket.js';");
  }
  if (options.fibonrose) {
    imports.push("import optimizeRouter from './routes/optimize.js';");
  }
  
  return `${imports.join('\n')}

dotenv.config();

const app = express();
const PORT = process.env.BACKEND_PORT || 3000;

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());

// Public routes
app.use('/api/health', healthRouter);
${options.deafauth ? "app.use('/api/auth', authRouter);" : ''}

// Protected routes
${options.pinksync ? "app.use('/api/sync', authMiddleware, syncRouter);" : ''}
${options.fibonrose ? "app.use('/api', authMiddleware, optimizeRouter);" : ''}

// Error handler
app.use((err: Error, req: express.Request, res: express.Response, _next: express.NextFunction) => {
  console.error('Error:', err.message);
  res.status(500).json({ success: false, message: 'Internal server error' });
});

// Start server
const server = app.listen(PORT, () => {
  console.log(\`${projectName} Backend running on port \${PORT}\`);
  console.log(\`Health check: http://localhost:\${PORT}/api/health\`);
});

${options.pinksync ? "createWebSocketServer(server);" : ''}

export default app;
`;
}

async function generateBackendRoutes(
  backendDir: string,
  options: ProjectOptions
): Promise<void> {
  // Health route
  const healthRoute = `import { Router } from 'express';

const router = Router();

router.get('/', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
  });
});

export default router;
`;
  await fs.writeFile(path.join(backendDir, 'src', 'routes', 'health.ts'), healthRoute);
  
  if (options.deafauth) {
    const authRoute = `import { Router } from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';

const router = Router();

// JWT secret must be set in production
const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET && process.env.NODE_ENV === 'production') {
  throw new Error('JWT_SECRET environment variable is required in production');
}
const jwtSecret = JWT_SECRET || 'dev-only-secret-change-in-production';

// In-memory user store (replace with database in production)
const users: Map<string, { id: string; username: string; email: string; password: string; accessibilityPreferences: object }> = new Map();

router.post('/register', async (req, res) => {
  try {
    const { username, email, password, accessibilityPreferences } = req.body;
    
    if (!username || !email || !password) {
      return res.status(400).json({ success: false, message: 'Missing required fields' });
    }
    
    if (users.has(username)) {
      return res.status(409).json({ success: false, message: 'User already exists' });
    }
    
    const hashedPassword = await bcrypt.hash(password, 10);
    const user = {
      id: \`user-\${Date.now()}\`,
      username,
      email,
      password: hashedPassword,
      accessibilityPreferences: accessibilityPreferences || {
        signLanguage: false,
        highContrast: false,
        largeText: false,
      },
    };
    
    users.set(username, user);
    
    res.status(201).json({
      success: true,
      user: { id: user.id, username: user.username, email: user.email, accessibilityPreferences: user.accessibilityPreferences },
    });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Registration failed' });
  }
});

router.post('/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    const user = users.get(username);
    if (!user) {
      return res.status(401).json({ success: false, message: 'Invalid credentials' });
    }
    
    const isValid = await bcrypt.compare(password, user.password);
    if (!isValid) {
      return res.status(401).json({ success: false, message: 'Invalid credentials' });
    }
    
    const token = jwt.sign({ userId: user.id, username: user.username }, jwtSecret, { expiresIn: '7d' });
    
    res.json({
      success: true,
      token,
      user: { id: user.id, username: user.username, email: user.email, accessibilityPreferences: user.accessibilityPreferences },
    });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Login failed' });
  }
});

router.get('/me', (req, res) => {
  const authHeader = req.headers.authorization;
  if (!authHeader?.startsWith('Bearer ')) {
    return res.status(401).json({ success: false, message: 'No token provided' });
  }
  
  try {
    const token = authHeader.slice(7);
    const decoded = jwt.verify(token, jwtSecret) as { username: string };
    const user = users.get(decoded.username);
    
    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }
    
    res.json({
      success: true,
      user: { id: user.id, username: user.username, email: user.email, accessibilityPreferences: user.accessibilityPreferences },
    });
  } catch (error) {
    res.status(401).json({ success: false, message: 'Invalid token' });
  }
});

export default router;
`;
    await fs.writeFile(path.join(backendDir, 'src', 'routes', 'auth.ts'), authRoute);
  }
  
  if (options.pinksync) {
    const syncRoute = `import { Router } from 'express';

const router = Router();

const syncChannels: Map<string, Set<string>> = new Map();

router.post('/', (req, res) => {
  const { channel, data } = req.body;
  
  if (!channel) {
    return res.status(400).json({ success: false, message: 'Channel is required' });
  }
  
  const syncId = \`sync-\${Date.now()}\`;
  
  res.json({
    success: true,
    syncId,
    message: \`Data synced to channel: \${channel}\`,
  });
});

router.get('/status', (req, res) => {
  res.json({
    success: true,
    status: 'connected',
    activeChannels: syncChannels.size,
    connectedClients: Array.from(syncChannels.values()).reduce((sum, s) => sum + s.size, 0),
  });
});

export default router;
`;
    await fs.writeFile(path.join(backendDir, 'src', 'routes', 'sync.ts'), syncRoute);
  }
  
  if (options.fibonrose) {
    const optimizeRoute = `import { Router } from 'express';

const router = Router();

router.post('/optimize/schedule', (req, res) => {
  const { tasks } = req.body;
  
  if (!Array.isArray(tasks)) {
    return res.status(400).json({ success: false, message: 'Tasks must be an array' });
  }
  
  // Fibonacci-based optimization
  const optimized = tasks.sort((a: { priority: number }, b: { priority: number }) => b.priority - a.priority);
  
  res.json({
    success: true,
    optimizedSchedule: optimized,
    efficiency: 0.95,
    message: 'Schedule optimized using Fibonacci algorithms',
  });
});

router.get('/fibonacci/:n', (req, res) => {
  const n = parseInt(req.params.n);
  
  if (isNaN(n) || n < 0 || n > 100) {
    return res.status(400).json({ success: false, message: 'N must be between 0 and 100' });
  }
  
  // Efficient O(n) Fibonacci calculation
  const fib = (num: number): number => {
    if (num <= 1) return num;
    let prev = 0, curr = 1;
    for (let i = 2; i <= num; i++) {
      const next = prev + curr;
      prev = curr;
      curr = next;
    }
    return curr;
  };
  
  res.json({
    success: true,
    position: n,
    value: fib(n),
  });
});

router.post('/golden-ratio', (req, res) => {
  const { value } = req.body;
  
  if (typeof value !== 'number') {
    return res.status(400).json({ success: false, message: 'Value must be a number' });
  }
  
  const goldenRatio = 1.618033988749895;
  
  res.json({
    success: true,
    inputValue: value,
    goldenRatio,
    multiplied: value * goldenRatio,
    divided: value / goldenRatio,
  });
});

export default router;
`;
    await fs.writeFile(path.join(backendDir, 'src', 'routes', 'optimize.ts'), optimizeRoute);
  }
}

async function generateBackendMiddleware(backendDir: string): Promise<void> {
  const authMiddleware = `import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

// JWT secret must be set in production
const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET && process.env.NODE_ENV === 'production') {
  throw new Error('JWT_SECRET environment variable is required in production');
}
const jwtSecret = JWT_SECRET || 'dev-only-secret-change-in-production';

export interface AuthRequest extends Request {
  userId?: string;
  username?: string;
}

export function authMiddleware(req: AuthRequest, res: Response, next: NextFunction): void {
  const authHeader = req.headers.authorization;
  
  if (!authHeader?.startsWith('Bearer ')) {
    res.status(401).json({ success: false, message: 'No token provided' });
    return;
  }
  
  try {
    const token = authHeader.slice(7);
    const decoded = jwt.verify(token, jwtSecret) as { userId: string; username: string };
    
    req.userId = decoded.userId;
    req.username = decoded.username;
    
    next();
  } catch (error) {
    res.status(401).json({ success: false, message: 'Invalid token' });
  }
}
`;
  await fs.writeFile(path.join(backendDir, 'src', 'middleware', 'auth.ts'), authMiddleware);
}

async function generateBackendServices(
  backendDir: string,
  options: ProjectOptions
): Promise<void> {
  if (options.pinksync) {
    const websocketService = `import { Server } from 'http';
import { WebSocketServer, WebSocket } from 'ws';

const channels: Map<string, Set<WebSocket>> = new Map();

export function createWebSocketServer(server: Server): WebSocketServer {
  const wss = new WebSocketServer({ server });
  
  wss.on('connection', (ws, req) => {
    const url = new URL(req.url || '/', \`http://\${req.headers.host}\`);
    const channel = url.pathname.split('/').pop() || 'default';
    
    // Add to channel
    if (!channels.has(channel)) {
      channels.set(channel, new Set());
    }
    channels.get(channel)?.add(ws);
    
    console.log(\`Client connected to channel: \${channel}\`);
    
    ws.on('message', (message) => {
      // Broadcast to all clients in the same channel
      const channelClients = channels.get(channel);
      if (channelClients) {
        channelClients.forEach((client) => {
          if (client !== ws && client.readyState === WebSocket.OPEN) {
            client.send(message);
          }
        });
      }
    });
    
    ws.on('close', () => {
      channels.get(channel)?.delete(ws);
      console.log(\`Client disconnected from channel: \${channel}\`);
    });
  });
  
  console.log('WebSocket server initialized');
  
  return wss;
}
`;
    await fs.writeFile(path.join(backendDir, 'src', 'services', 'websocket.ts'), websocketService);
  }
}

async function generateEnvFiles(
  outputDir: string,
  options: ProjectOptions
): Promise<void> {
  const envContent = `# Server
BACKEND_PORT=3000
NODE_ENV=development

# JWT - IMPORTANT: Change this before deploying to production!
JWT_SECRET=CHANGE-ME-IN-PRODUCTION-GENERATE-A-RANDOM-SECRET
JWT_EXPIRY=7d

# Frontend
VITE_API_URL=http://localhost:3000/api
${options.pinksync ? 'VITE_WS_URL=ws://localhost:3000' : ''}

# Database (optional)
DATABASE_URL=postgresql://user:password@localhost:5432/myapp

# Services
${options.deafauth ? 'DEAFAUTH_URL=http://localhost:3002' : ''}
${options.pinksync ? 'PINKSYNC_URL=http://localhost:3003' : ''}
${options.fibonrose ? 'FIBONROSE_URL=http://localhost:3004' : ''}
${options.ai ? 'AI_SERVICE_URL=http://localhost:3006\nOPENAI_API_KEY=your-openai-key' : ''}
`;

  await fs.writeFile(path.join(outputDir, '.env.example'), envContent);
}

async function generateReadme(
  outputDir: string,
  projectName: string,
  options: ProjectOptions
): Promise<void> {
  const readme = `# ${projectName}

A production-ready SaaS application powered by the DEAF-FIRST Platform.

## Features

${options.deafauth ? '- üîê **DeafAUTH** - Accessible authentication with sign language support' : ''}
${options.pinksync ? '- üîÑ **PinkSync** - Real-time data synchronization' : ''}
${options.fibonrose ? '- üìä **FibonRose** - Mathematical optimization algorithms' : ''}
${options.deafUi ? '- ‚ôø **Deaf UI** - Accessible component library' : ''}
${options.ai ? '- ü§ñ **AI Services** - AI-powered workflows and automation' : ''}

## Quick Start

### Prerequisites

- Node.js >= 20.0.0
- npm >= 10.0.0

### Installation

1. Install dependencies:
\`\`\`bash
npm install
\`\`\`

2. Set up environment variables:
\`\`\`bash
cp .env.example .env
# Edit .env with your configuration
\`\`\`

3. Start development servers:
\`\`\`bash
npm run dev
\`\`\`

The frontend will be available at http://localhost:5173
The backend API will be available at http://localhost:3000

## Project Structure

\`\`\`
${projectName}/
‚îú‚îÄ‚îÄ frontend/           # React frontend application
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/ # Reusable UI components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/      # Custom React hooks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/   # API service modules
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/      # Page components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.tsx     # Main app component
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.tsx    # Entry point
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ backend/            # Express backend API
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/     # API route handlers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware/ # Express middleware
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/   # Business logic services
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts    # Server entry point
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ .env.example        # Environment variables template
‚îú‚îÄ‚îÄ package.json        # Root package.json
‚îî‚îÄ‚îÄ README.md
\`\`\`

## Development Scripts

| Command | Description |
|---------|-------------|
| \`npm run dev\` | Start all services in development mode |
| \`npm run dev:frontend\` | Start frontend only |
| \`npm run dev:backend\` | Start backend only |
| \`npm run build\` | Build all services for production |
| \`npm run test\` | Run all tests |
| \`npm run lint\` | Lint all code |

## Accessibility

This application is built with accessibility as a core principle:

- WCAG 2.1 AA compliant
- Keyboard navigation support
- Screen reader compatible
- High contrast mode support
- Reduced motion support
- Sign language integration (with DeafAUTH)

## API Endpoints

### Authentication
${options.deafauth ? `
- \`POST /api/auth/register\` - Register new user
- \`POST /api/auth/login\` - User login
- \`GET /api/auth/me\` - Get current user
` : 'Authentication not enabled'}

### Sync
${options.pinksync ? `
- \`POST /api/sync\` - Sync data to channel
- \`GET /api/sync/status\` - Get sync status
- WebSocket endpoint for real-time updates
` : 'Sync not enabled'}

### Optimization
${options.fibonrose ? `
- \`POST /api/optimize/schedule\` - Optimize task schedule
- \`GET /api/fibonacci/:n\` - Calculate Fibonacci number
- \`POST /api/golden-ratio\` - Golden ratio calculations
` : 'Optimization not enabled'}

## License

MIT License

---

Generated by DEAF-FIRST Platform Generator
`;

  await fs.writeFile(path.join(outputDir, 'README.md'), readme);
}
